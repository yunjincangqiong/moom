### 语法

```
空数组（[]）和空对象（{}）对应的布尔值，都是true
对象有两种读取成员的方法：“点”结构（object.key）和方括号结构（object[key]）
将数组清空的一个有效方法，就是将length属性设为0。
Object.keys() 取数组或者对象的键组成的数组 Object.values() 取数组或者对象的值组成的数组
else代码块总是跟随离自己最近的那个if语句
valueOf()：返回最适合该对象类型的原始值   例如数组 [1,2]就会返回原始值数组 [1,2]
toString(): 将该对象的原始值以字符串形式返回   数组 [1,2]就会字符串 '1,2'
由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心
0除以0也会得到NaN
typeof NaN 为Number  也就说 NaN 为特殊的数字类型
```

```
try{}-catch(e){}-finally{}
先执行try中的代码  如果有错误就抛出异常给catch  执行catch中的代码 如果catch中有 return 和 throw 语句暂时不去返回数据或者抛出异常(此时数据就已经固定 不会受finally的代码执行影响)  转去执行finally中的代码  如果 finally中有return false 则结束代码执行  否则就在执行完finally代码后 在抛出异常或者返回数据
```

### 数组

```
JavaScript语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。

var arr = ['a', 'b', 'c'];

arr['0'] // 'a'
arr[0] // 'a'
```

```
需要注意的是，这一条在赋值时也成立。如果一个值可以被转换为整数，则以该值为键名，等于以对应的整数为键名。
var a = [];

a['1000'] = 'abc';
a[1000] // 'abc'

a[1.00] = 6;
a[1] // 6
上面代码表明，由于字符串“1000”和浮点数1.00都可以转换为整数，所以视同为整数键赋值。
```

```
length属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员会自动减少到length设置的值。
var arr = [ 'a', 'b', 'c' ];
arr.length // 3

arr.length = 2;
arr // ["a", "b"]
上面代码表示，当数组的length属性设为2（即最大的整数键只能是1）那么整数键2（值为c）就已经不在数组中了，被自动删除了。
```

```
值得注意的是，由于数组本质上是对象的一种，所以我们可以为数组添加属性，但是这不影响length属性的值。
var a = [];

a['p'] = 'abc';
a.length // 0

a[2.1] = 'abc';
a.length // 0
上面代码将数组的键分别设为字符串和小数，结果都不影响length属性。因为，length属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以length属性保持为0。
```

```
[].slice.call(伪数组)  或者  Array.prototype.slice.call(伪数组)   返回一个数组数据
伪数组可以使用数组的方法(执行时间比较慢 所以建议将伪数组变为数组 在进行数组操作)
forEach every some filter map find findIndex
Array.prototype.forEach.call(arguments, function (elem, i, arr) {
  console.log(i+'. '+elem);
});
```

```
需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。

var a = [1, 2, 3,];

a.length // 3
a // [1, 2, 3]
```

### 函数

```
var foo = function x(){}
上面代码在函数表达式中，加入了函数名x。这个x只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）
```

#### 函数自身作用域(重点)

```
函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。

var a = 1;
var x = function () {
  console.log(a);
};

function f() {
  var a = 2;
  x();
}

f() // 1
上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。

总之，函数执行时所在的作用域(结合作用域链)，是定义时的作用域，而不是调用时所在的作用域。
```

```
默认值问题
更精确的写法  这样在输入值为''或者0时 也会正常赋值
(a !== undefined && a !== null) ? a = a : a = 1;
```

```
某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。

var a = 1;

function f(p) {
  window[p] = 2;
}
f('a');

a // 2
上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。
```

```
正常模式下，arguments对象可以在运行时修改。

var f = function(a, b) {
  arguments[0] = 3;
  arguments[1] = 2;
  return a + b;
}

f(1, 1) // 5
严格模式下不可以修改  但是修改不会报错
```

```
(function (){})()  或者   (function(){}())
通常情况下，只对匿名函数使用这种 立即执行的函数表达式 (IIFE)。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。
```

### eval

```
eval命令的作用是，将字符串当作语句执行。

eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。
var a = 1;
eval('a = 2');
a // 2

使用严格模式时,eval内部声明的变量,不会影响到外部作用域.等同于函数作用域,可以访问并改变外边的全局变量数据

eval 存在运行速度上的问题所以不建议使用
```



